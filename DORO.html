<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>DORO射的ゲーム（完全修正版）</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />

<!-- p5.js 本体 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js"></script>
<!-- 音再生用ライブラリ -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/addons/p5.sound.min.js"></script>

<style>
  html,body{height:100%;margin:0;background:#222;color:#fff;font-family:system-ui}
  #hint{position:fixed;left:12px;top:12px;background:rgba(0,0,0,0.36);
        padding:8px 10px;border-radius:8px;font-size:13px;z-index:10}
</style>
</head>

<body>
<div id="hint">Hold mouse: shoot. Auto reload.</div>

<script>
// ======================================================
// 基本変数
// ======================================================
const tableTopLeftX  = 230;
const tableTopRightX = 570;
const tableBottomLeftX  = 80;
const tableBottomRightX = 720;
const tableTopY = 140;
const tableBottomY = 440;
const laneCount = 5;

let doroRemaining = 100;

// 弾
let maxAmmo = 30;
let ammo = maxAmmo;
let fireInterval = 200;
let lastFireTime = 0;
let reloadTime = 500;
let isReloading = false;

// クロスヘアアニメ
let crosshairSpread = 0;
let crosshairTargetSpread = 0;

// 射撃音
let shootSound = null;

// クリアタイム
let startTime = 0;
let clearTime = 0;
let gameCleared = false;

// 状態
let screenState = "start";

let lanes = [];
let targets = [];
let bullets = [];
let targetImg;

// ======================================================
// setup
// ======================================================
function setup(){
  createCanvas(900, 600);

  // ターゲット画像（無くても動く）
  targetImg = loadImage("images/doro-removebg-preview.png", ()=>{}, ()=>{});

  // 射撃音ロード
  try{
    shootSound = loadSound("sound/射撃音.MP3");
  }catch(e){
    shootSound = null;
  }
}

// ======================================================
// draw
// ======================================================
function draw(){
  background(36,42,64);

  if(screenState === "start"){
    drawStartScreen();
    cursor();
  }
  else if(screenState === "instructions"){
    drawInstructionsScreen();
    cursor();
  }
  else if(screenState === "game"){
    noCursor();
    drawGame();
  }
}

// ======================================================
// スタート画面
// ======================================================
function drawStartScreen(){
  push();
  fill(255);
  textAlign(CENTER, CENTER);
  textSize(48);
  text("DOROゲーム", width/2, height/2 - 80);

  rectMode(CENTER);
  fill(50,150,255);
  rect(width/2, height/2, 180, 50, 12);
  fill(255);
  textSize(24);
  text("スタート", width/2, height/2);

  fill(50,200,100);
  rect(width/2, height/2 + 80, 180, 50, 12);
  fill(255);
  text("プレイ方法", width/2, height/2+80);
  pop();
}

function drawInstructionsScreen(){
  push();
  fill(255);
  textAlign(CENTER,CENTER);
  textSize(36);
  text("プレイ方法", width/2, height/2 - 60);
  textSize(24);
  text("DOROを素早く倒したら勝ち！", width/2, height/2 + 10);
  textSize(18);
  text("クリックで戻る", width/2, height/2 + 80);
  pop();
}

// ======================================================
// ゲーム画面
// ======================================================
function drawGame(){
  drawTable();
  updateTargets();
  drawTargets();
  updateBullets();
  drawBullets();
  drawCrosshair();
  handleShooting();
  drawUI();

  if(!gameCleared && doroRemaining <= 0){
    clearTime = (millis() - startTime)/1000;
    gameCleared = true;
  }
}

// ======================================================
// シーン初期化
// ======================================================
function initScene(){
  lanes = [];
  targets = [];
  bullets = [];
  ammo = maxAmmo;
  isReloading = false;
  lastFireTime = 0;
  gameCleared = false;

  const minGap = 20;
  const maxGap = 95;
  let y = tableTopY + 12;

  for(let i=0;i<laneCount;i++){
    const t = i/(laneCount-1);
    const gap = lerp(minGap, maxGap, t);
    const size = lerp(34,78,t);
    const speed= lerp(1.4,3.6,t);

    const leftX = map(y, tableTopY, tableBottomY, tableTopLeftX, tableBottomLeftX);
    const rightX= map(y, tableTopY, tableBottomY, tableTopRightX, tableBottomRightX);

    lanes.push({y,leftX,rightX,size,speed});

    const amp = lerp(22,30,t);
    const phase = random(TWO_PI);

    for(let j=0;j<Math.ceil(doroRemaining/laneCount); j++){
      const xPos = random(leftX+20, rightX-20);
      targets.push({
        lane:i,
        baseX:xPos,
        x:xPos,
        currentY:y,
        baseY:y,
        size,
        dir:random([-1,1]),
        speed,
        alive:true,
        bounceAmp:amp,
        bouncePhase:phase,
        bounceFreq:lerp(0.06,0.12,random()),
        vx:0, vy:0
      });
    }
    y += gap;
  }

  startTime = millis();
}

// ======================================================
// ターゲット更新
// ======================================================
function updateTargets(){
  for(let t of targets){
    if(!t.alive) continue;

    const L = lanes[t.lane];
    const d = dist(mouseX,mouseY,t.x,t.baseY);

    // 近づくと逃げる
    if(d < 200){
      const ang = atan2(t.baseY - mouseY, t.x - mouseX);
      t.vx += cos(ang)*0.35;
      t.vy += sin(ang)*0.12;
    } else {
      t.vx += t.speed * t.dir * 0.06;
    }

    // ランダム揺れ
    t.vx += random(-0.04,0.04);
    t.vx = constrain(t.vx,-4.5,4.5);
    t.vy = constrain(t.vy,-1.2,1.2);

    // 位置更新
    t.x += t.vx;
    t.baseY += t.vy;
    t.baseY = lerp(t.baseY, L.y, 0.04);

    // はみ出し処理
    const leftBound = L.leftX + 12;
    const rightBound= L.rightX - 12;
    if(t.x < leftBound) t.x = rightBound - 2;
    if(t.x > rightBound) t.x = leftBound + 2;

    // バウンド動作
    const time = frameCount;
    const bounce = sin(time*t.bounceFreq + t.bouncePhase) * t.bounceAmp;
    t.currentY = t.baseY - abs(bounce);
  }
}

// ======================================================
// ターゲット描画
// ======================================================
function drawTargets(){
  imageMode(CENTER);
  for(let t of targets){
    if(!t.alive) continue;

    push();
    translate(t.x, t.currentY);
    if(t.vx > 0) scale(-1,1);

    if(targetImg && targetImg.width > 0){
      image(targetImg, 0,0,t.size,t.size);
    } else {
      fill(255,100,100);
      ellipse(0,0,t.size);
    }

    pop();
  }
}

// ======================================================
// 弾処理
// ======================================================
function handleShooting(){
  if(!mouseIsPressed || ammo <= 0){
    if(!isReloading && ammo < maxAmmo){
      isReloading = true;
      setTimeout(()=>{
        ammo = maxAmmo;
        isReloading = false;
      }, reloadTime);
    }
    return;
  }

  const now = millis();
  if(now - lastFireTime > fireInterval && !isReloading){
    fireBullet();
    lastFireTime = now;
    ammo--;

    crosshairTargetSpread = 12; // 撃つと広がる
  }
}

// 弾生成
function fireBullet(){
  // ★ 撃つ音
  try{
    if (shootSound && shootSound.isLoaded && shootSound.isLoaded()) {
      shootSound.play();
    }
  }catch(e){}

  const ox = width/2;
  const oy = height - 6;
  const dx = mouseX - ox;
  const dy = mouseY - oy;
  const d = sqrt(dx*dx + dy*dy)||1;

  bullets.push({
    x:ox, y:oy,
    vx:(dx/d)*20,
    vy:(dy/d)*20
  });
}

// 弾移動
function updateBullets(){
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    b.x += b.vx;
    b.y += b.vy;

    if(b.x<-50 || b.x>width+50 || b.y<-50 || b.y>height+50){
      bullets.splice(i,1);
      continue;
    }

    let hit = false;
    for(let t of targets){
      if(!t.alive) continue;
      const d = dist(b.x,b.y,t.x,t.currentY);
      if(d <= t.size*0.5){
        t.alive=false;
        bullets.splice(i,1);
        if(doroRemaining>0) doroRemaining--;
        hit=true;
        break;
      }
    }
  }
}

// 弾描画
function drawBullets(){
  noStroke();
  fill(255,230,130);
  for(let b of bullets){
    ellipse(b.x,b.y,12);
  }
}

// ======================================================
// クロスヘア（撃つと広がる）
// ======================================================
function drawCrosshair(){
  crosshairSpread = lerp(crosshairSpread, crosshairTargetSpread, 0.15);
  crosshairTargetSpread *= 0.85;

  const cx = mouseX;
  const cy = mouseY;

  push();
  stroke(255);
  strokeWeight(2);

  // 縦線
  line(cx, cy - 15 - crosshairSpread, cx, cy - 5);
  line(cx, cy + 5, cx, cy + 15 + crosshairSpread);

  // 横線
  line(cx - (15 + crosshairSpread), cy, cx - 5, cy);
  line(cx + 5, cy, cx + (15 + crosshairSpread), cy);

  pop();
}

// ======================================================
// UI（残弾バー）
// ======================================================
function drawUI(){

  push();
  fill(255);
  textSize(16);
  text(`DORO残り ${doroRemaining}匹`, 12, 50);
  pop();

  // ----- 残弾バー -----
  const barWidth = 50;
  const barHeight = 12;

  const barX = mouseX - 70;
  const barY = mouseY - barHeight/2;

  let barColor;
  if(isReloading || ammo <= 0) barColor = color(150);
  else if(ammo <= maxAmmo/2)  barColor = color(255,0,0);
  else barColor = color(255);

  push();
  noStroke();
  fill(80);
  rect(barX, barY, barWidth, barHeight, 4);

  fill(barColor);
  rect(barX, barY, (ammo/maxAmmo)*barWidth, barHeight, 4);
  pop();

  // 三桁カウンター
  push();
  textSize(16);
  fill(barColor);
  text(String(ammo).padStart(3,"0"), barX, barY + barHeight + 4);
  pop();

  // クリアタイム
  if(gameCleared){
    push();
    textSize(20);
    fill(255);
    textAlign(CENTER);
    text(`クリアタイム: ${clearTime.toFixed(2)}秒`, width/2, 30);
    pop();
  }
}

// ======================================================
// テーブル（★修正版）
// ======================================================
function drawTable(){
  noStroke();
  fill(145,100,60);

  // ★バグ修正済み quad
  quad(
    tableTopLeftX, tableTopY,
    tableTopRightX, tableTopY,
    tableBottomRightX, tableBottomY,
    tableBottomLeftX, tableBottomY
  );
}

// ======================================================
// mousePressed
// ======================================================
function mousePressed(){

  // ★ Chrome の音声ロック解除
  if (getAudioContext().state !== "running") {
    getAudioContext().resume();
  }

  if(screenState==="start"){
    if(mouseX>width/2-90 && mouseX<width/2+90 &&
       mouseY>height/2-25 && mouseY<height/2+25){
      screenState="game";
      initScene();
      return;
    }

    if(mouseX>width/2-90 && mouseX<width/2+90 &&
       mouseY>height/2+55 && mouseY<height/2+105){
      screenState="instructions";
      return;
    }
  }
  else if(screenState==="instructions"){
    screenState="start";
  }
}
</script>
</body>
</html>
