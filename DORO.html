<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>DORO射撃ゲーム（完全統合版 — スコア実装）</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/addons/p5.sound.min.js"></script>

<style>
  body { margin:0; background:#222; color:#fff; font-family:sans-serif; }
  #hint { position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.4); padding: 8px 12px; font-size: 14px; border-radius: 6px; }
  .btn {
    background:#3aa; color:#fff; padding:8px 12px; border-radius:6px; cursor:pointer; display:inline-block; margin-top:8px;
  }
</style>
</head>
<body>

<div id="hint">Hold mouse to shoot / Auto reload</div>

<script>
// =========================
// 変数・定義
// =========================
const tableTopLeftX  = 230;
const tableTopRightX = 570;
const tableBottomLeftX  = 80;
const tableBottomRightX = 720;
const tableTopY = 140;
const tableBottomY = 440;
const laneCount = 5;

let doroRemaining = 100;

let maxAmmo = 30;
let ammo = maxAmmo;
let fireInterval = 200;
let lastFireTime = 0;
let reloadTime = 500;
let isReloading = false;

let crosshairSpread = 0;
let crosshairTargetSpread = 0;

let longShootSound = null;   // 射撃音（長尺）
let reloadSound = null;      // リロード音
let isLongSoundPlaying = false;

let startTime = 0;
let clearTime = 0;
let gameCleared = false;

let screenState = "start";

let lanes = [];
let targets = [];
let bullets = [];
let targetImg = null;

// --- スコア用
const BASE_SCORE = 10000;
let missedShots = 0; // 画面外に出た弾をカウント
let lastScore = 0;
let highScore = 0;
const HIGH_KEY = "doro_highscore";

// =========================
// preload（音と画像読み込み）
// =========================
function preload() {
  // 射撃音
  try {
    longShootSound = loadSound("sound/shot.mp3",
      () => console.log("longShootSound loaded"),
      (e) => console.warn("longShootSound load failed", e)
    );
  } catch(e) { console.warn(e); }

  // リロード音
  try {
    reloadSound = loadSound("sound/reload.mp3",
      () => console.log("reloadSound loaded"),
      (e) => console.warn("reloadSound load failed", e)
    );
  } catch(e) { console.warn(e); }

  // 的画像
  try {
    targetImg = loadImage("images/doro-removebg-preview.png",
      () => console.log("targetImg loaded"),
      (e) => console.warn("targetImg load failed", e)
    );
  } catch(e) { console.warn(e); }
}

// =========================
function setup() {
  createCanvas(900, 600);

  // 初期音量
  try { if(longShootSound) longShootSound.setVolume(1.0); } catch(e){}
  try { if(reloadSound) reloadSound.setVolume(1.0); } catch(e){}

  // ハイスコア読み込み
  const stored = localStorage.getItem(HIGH_KEY);
  highScore = stored ? parseInt(stored,10) || 0 : 0;
}

// =========================
function draw() {
  background(36,42,64);

  if(screenState === "start"){ drawStartScreen(); cursor(); }
  else if(screenState === "instructions"){ drawInstructionsScreen(); cursor(); }
  else if(screenState === "game"){ noCursor(); drawGame(); }
  else if(screenState === "clear"){ noCursor(); drawClearScreen(); }
}

// =========================
// 画面描画
// =========================
function drawStartScreen(){
  push();
  fill(255);
  textAlign(CENTER);
  textSize(48);
  text("DOROゲーム", width/2, height/2 - 80);

  rectMode(CENTER);

  fill(50,150,255);
  rect(width/2, height/2, 200, 60, 12);
  fill(255);
  textSize(26);
  text("スタート", width/2, height/2);

  fill(50,200,120);
  rect(width/2, height/2 + 90, 200, 60, 12);
  fill(255);
  text("プレイ方法", width/2, height/2 + 90);
  pop();
}

function drawInstructionsScreen(){
  push();
  fill(255);
  textAlign(CENTER);
  textSize(38);
  text("プレイ方法", width/2, height/2 - 60);
  textSize(22);
  text("DOROを素早く倒したら勝ち！", width/2, height/2 + 10);
  textSize(18);
  text("クリックで戻る", width/2, height/2 + 80);
  pop();
}

// =========================
function drawGame(){
  drawTable();
  updateTargets();
  drawTargets();
  updateBullets();
  drawBullets();
  drawCrosshair();
  handleShooting();
  drawUI();

  if(!gameCleared && doroRemaining <= 0){
    clearTime = (millis() - startTime)/1000;
    gameCleared = true;
    // スコア計算 & クリア画面へ
    computeScoreAndSave();
    screenState = "clear";
  }
}

// =========================
function initScene(){
  lanes=[]; targets=[]; bullets=[];
  ammo = maxAmmo;
  isReloading = false;
  lastFireTime = 0;
  gameCleared = false;
  isLongSoundPlaying = false;
  missedShots = 0;
  lastScore = 0;

  const minGap = 20; const maxGap = 95;
  let y = tableTopY + 12;

  for(let i=0;i<laneCount;i++){
    const t = i/(laneCount-1);
    const gap = lerp(minGap,maxGap,t);
    const size = lerp(34,78,t);
    const speed = lerp(1.4,3.6,t);

    const leftX = map(y,tableTopY,tableBottomY,tableTopLeftX,tableBottomLeftX);
    const rightX= map(y,tableTopY,tableBottomY,tableTopRightX,tableBottomRightX);

    lanes.push({y,leftX,rightX,size,speed});

    const amp = lerp(22,30,t);
    const phase = random(TWO_PI);

    for(let j=0;j<Math.ceil(doroRemaining/laneCount); j++){
      const xPos = random(leftX+20,rightX-20);
      targets.push({
        lane:i, baseX:xPos, x:xPos, currentY:y, baseY:y,
        size, dir:random([-1,1]), speed,
        alive:true,
        bounceAmp:amp, bouncePhase:phase, bounceFreq:lerp(0.06,0.12,random()),
        vx:0, vy:0
      });
    }
    y += gap;
  }

  startTime = millis();
}

// =========================
// 的の更新
// =========================
function updateTargets(){
  for(let t of targets){
    if(!t.alive) continue;

    const L = lanes[t.lane];
    const d = dist(mouseX,mouseY,t.x,t.baseY);

    if(d < 200){
      const ang = atan2(t.baseY - mouseY, t.x - mouseX);
      t.vx += cos(ang)*0.35; t.vy += sin(ang)*0.12;
    } else {
      t.vx += t.speed * t.dir * 0.06;
    }

    t.vx += random(-0.04,0.04);
    t.vx = constrain(t.vx,-4.5,4.5);
    t.vy = constrain(t.vy,-1.2,1.2);

    t.x += t.vx;
    t.baseY += t.vy;
    t.baseY = lerp(t.baseY, L.y, 0.04);

    const leftBound = L.leftX + 12;
    const rightBound = L.rightX - 12;

    if(t.x < leftBound) t.x = rightBound - 2;
    if(t.x > rightBound) t.x = leftBound + 2;

    const time = frameCount;
    const bounce = sin(time*t.bounceFreq + t.bouncePhase) * t.bounceAmp;
    t.currentY = t.baseY - abs(bounce);
  }
}

function drawTargets(){
  imageMode(CENTER);
  for(let t of targets){
    if(!t.alive) continue;
    push();
    translate(t.x,t.currentY);
    if(t.vx>0) scale(-1,1);
    if(targetImg) image(targetImg,0,0,t.size,t.size);
    else { fill(255,100,100); ellipse(0,0,t.size); }
    pop();
  }
}

// =========================
// 弾
// =========================
function fireBullet(){
  const ox = width/2;
  const oy = height - 10;
  const dx = mouseX - ox;
  const dy = mouseY - oy;
  const d = sqrt(dx*dx + dy*dy)||1;

  bullets.push({
    x:ox, y:oy,
    vx:(dx/d)*20, vy:(dy/d)*20
  });
}

function updateBullets(){
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];

    b.x += b.vx;
    b.y += b.vy;

    // 画面外に出た場合 → ミスとしてカウントして削除
    if(b.x < -50 || b.x > width+50 || b.y < -50 || b.y > height+50){
      missedShots++; // 追加：外した弾をカウント
      bullets.splice(i,1);
      continue;
    }

    for(let t of targets){
      if(!t.alive) continue;

      const d = dist(b.x,b.y,t.x,t.currentY);
      if(d <= t.size*0.5){
        t.alive = false;
        bullets.splice(i,1);
        if(doroRemaining>0) doroRemaining--;
        break;
      }
    }
  }
}

function drawBullets(){
  noStroke();
  fill(255,230,130);
  for(let b of bullets) ellipse(b.x,b.y,12);
}

// =========================
// クロスヘア
// =========================
function drawCrosshair(){
  crosshairSpread = lerp(crosshairSpread, crosshairTargetSpread, 0.15);
  crosshairTargetSpread *= 0.85;

  const cx = mouseX;
  const cy = mouseY;

  push();
  stroke(255); strokeWeight(2);

  line(cx, cy - 20 - crosshairSpread, cx, cy - 5);
  line(cx, cy + 5, cx, cy + 20 + crosshairSpread);

  line(cx - (20 + crosshairSpread), cy, cx - 5, cy);
  line(cx + 5, cy, cx + (20 + crosshairSpread), cy);

  pop();
}

// =========================
// UI
// =========================
function drawUI(){
  push();
  fill(255); textSize(16);
  text(`DORO残り ${doroRemaining}匹`, 10, 50);
  pop();

  // 弾数バー
  const barX = mouseX - 70;
  const barY = mouseY - 20;
  const barW = 60;
  const barH = 10;

  let barColor = color(255);
  if(isReloading || ammo <= 0) barColor = color(150);
  else if(ammo <= maxAmmo/2) barColor = color(255,0,0);

  push();
  noStroke();
  fill(80);
  rect(barX, barY, barW, barH, 4);
  fill(barColor);
  rect(barX, barY, (ammo/maxAmmo)*barW, barH, 4);
  pop();

  // 数字
  push();
  textSize(14);
  fill(barColor);
  text(String(ammo).padStart(3,"0"), barX, barY + barH + 14);
  pop();

  // ミスカウンタ（画面に表示）
  push();
  textSize(14);
  fill(255);
  text(`外した弾: ${missedShots}`, 10, 70);
  pop();

  if(gameCleared){
    push();
    fill(255); textSize(20);
    textAlign(CENTER);
    text(`クリアタイム: ${clearTime.toFixed(2)}秒`, width/2, 40);
    pop();
  }
}

// =========================
// 射撃・リロード（音含む）
// =========================
function handleShooting(){

  // マウス離し or 残弾なし
  if(!mouseIsPressed || ammo <= 0){

    // 射撃音停止
    if(isLongSoundPlaying){
      try { longShootSound.stop(); } catch(e){}
      isLongSoundPlaying = false;
    }

    // 自動リロード
    if(!isReloading && ammo < maxAmmo){

      isReloading = true;

      // リロード音再生
      try {
        if(reloadSound?.isLoaded && reloadSound.isLoaded()) reloadSound.play();
        else reloadSound?.play?.();
      } catch(e){}

      setTimeout(()=>{
        ammo = maxAmmo;
        isReloading = false;
      }, reloadTime);
    }

    return;
  }

  // 射撃開始 → 長尺射撃音を1回だけ再生
  if(!isLongSoundPlaying){
    try {
      if(getAudioContext().state !== "running") getAudioContext().resume();
    } catch(e){}
    try {
      if(longShootSound?.isLoaded && longShootSound.isLoaded()){
        longShootSound.play();
      } else {
        longShootSound?.play?.();
      }
      isLongSoundPlaying = true;
    } catch(e){
      console.warn("longShootSound play error:", e);
    }
  }

  // 通常弾発射
  const now = millis();
  if(now - lastFireTime > fireInterval && !isReloading){
    fireBullet();
    lastFireTime = now;
    ammo--;
    crosshairTargetSpread = 12;
  }
}

// =========================
// スコア計算・保存
// =========================
function computeScoreAndSave(){
  // ペナルティ設定（必要ならここを調整）
  const timePenaltyPerSec = 100;   // 秒 × 100
  const missPenalty = 200;         // 1ミスあたり 200 点

  const timePenalty = Math.floor(clearTime * timePenaltyPerSec);
  const missPenaltyTotal = missedShots * missPenalty;

  let score = BASE_SCORE - timePenalty - missPenaltyTotal;
  if(score < 0) score = 0;

  lastScore = score;

  // ハイスコア更新
  if(score > highScore){
    highScore = score;
    try { localStorage.setItem(HIGH_KEY, String(highScore)); } catch(e){}
  }
}

// =========================
// クリア画面描画
// =========================
function drawClearScreen(){
  push();
  fill(255);
  textAlign(CENTER);
  textSize(56);
  text("CLEAR!", width/2, height/2 - 120);

  textSize(20);
  text(`クリア時間: ${clearTime.toFixed(2)} 秒`, width/2, height/2 - 60);
  text(`外した弾: ${missedShots} 発`, width/2, height/2 - 30);

  // スコア内訳
  const timePenaltyPerSec = 50;
  const missPenalty = 20;
  const timePenalty = Math.floor(clearTime * timePenaltyPerSec);
  const missPenaltyTotal = missedShots * missPenalty;
  textSize(18);
  text(`計算: ${BASE_SCORE} - (時間 ${Math.floor(clearTime)}s × ${timePenaltyPerSec}) - (外し ${missedShots} × ${missPenalty})`, width/2, height/2 + 0);

  textSize(36);
  text(`スコア: ${lastScore}`, width/2, height/2 + 60);

  textSize(18);
  text(`ハイスコア: ${highScore}`, width/2, height/2 + 100);

  // 再挑戦ボタン（簡易）
  textSize(16);
  fill(200,230,255);
  rectMode(CENTER);
  rect(width/2 - 120, height/2 + 150, 160, 44, 8);
  fill(20);
  text("リトライ", width/2 - 120, height/2 + 150);

  fill(200,230,255);
  rect(width/2 + 120, height/2 + 150, 160, 44, 8);
  fill(20);
  text("タイトルへ", width/2 + 120, height/2 + 150);

  // クリック判定は mousePressedClearScreen() に移譲
  pop();
}

function mousePressed(){
  // 音のロック解除（ユーザー操作で必ず呼ぶ）
  try {
    if(getAudioContext().state !== "running") getAudioContext().resume();
  } catch(e){}

  if(screenState === "start"){
    // スタート
    if(mouseX > width/2-100 && mouseX < width/2+100 &&
       mouseY > height/2-30 && mouseY < height/2+30){
      screenState = "game";
      initScene();
      return;
    }
    // プレイ方法
    if(mouseX > width/2-100 && mouseX < width/2+100 &&
       mouseY > height/2+60 && mouseY < height/2+120){
      screenState = "instructions";
      return;
    }
  } else if(screenState === "instructions"){
    screenState = "start";
  } else if(screenState === "game"){
    // ゲーム中の射撃は draw の handleShooting が判定（押しっぱなしで射撃）
    // ここは特に何もしない（ただし start -> game の切替は上で処理済み）
  } else if(screenState === "clear"){
    // クリア画面のボタン判定
    // リトライ ボタン
    const retryX = width/2 - 120, retryY = height/2 + 150, w=160, h=44;
    if(mouseX > retryX - w/2 && mouseX < retryX + w/2 && mouseY > retryY - h/2 && mouseY < retryY + h/2){
      // リトライ：DOROを再セット（同じ設定）
      doroRemaining = 100;
      screenState = "game";
      initScene();
      return;
    }
    // タイトルへ
    const titleX = width/2 + 120, titleY = height/2 + 150;
    if(mouseX > titleX - w/2 && mouseX < titleX + w/2 && mouseY > titleY - h/2 && mouseY < titleY + h/2){
      screenState = "start";
      return;
    }
  }
}

// =========================
// テーブル描画
// =========================
function drawTable(){
  noStroke();
  fill(145,100,60);
  quad(
    tableTopLeftX, tableTopY,
    tableTopRightX, tableTopY,
    tableBottomRightX, tableBottomY,
    tableBottomLeftX, tableBottomY
  );
}
</script>
</body>
</html>
