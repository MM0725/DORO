<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>射的ゲーム（DORO・弾30・クリアタイム版）</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js"></script>
<style>
  html,body{height:100%;margin:0;background:#222;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN",Meiryo}
  #hint{position:fixed;left:12px;top:12px;background:rgba(0,0,0,0.36);padding:8px 10px;border-radius:8px;font-size:13px;z-index:10}
</style>
</head>
<body>
<div id="hint">Hold mouse: shoot. Bullets hit targets or leave screen. Auto reload when released or empty.</div>

<script>
// =======================
// Config / Scene params
// =======================
const tableTopLeftX  = 230;
const tableTopRightX = 570;
const tableBottomLeftX  = 80;
const tableBottomRightX = 720;

const tableTopY = 140;
const tableBottomY = 440;

const laneCount = 5;

// DORO関連
let doroRemaining = 100;

// 弾関連
let maxAmmo = 30;
let ammo = maxAmmo;
let fireInterval = 200;
let lastFireTime = 0;
let reloadTime = 500;
let isReloading = false;

// クリアタイム計測
let startTime;
let clearTime = null;
let gameCleared = false;

// 画面状態
// start:スタート画面 / instructions:プレイ方法 / game:ゲーム中
let screenState = "start";

// 描画用
let lanes = [];
let targets = [];
let bullets = [];
let targetImg;

// =======================
// p5.js setup
// =======================
function setup(){
  createCanvas(900, 600);
  targetImg = loadImage("images/doro-removebg-preview.png");
}

// =======================
// p5.js draw
// =======================
function draw(){
  background(36,42,64);

  if(screenState === "start"){
    drawStartScreen();
    cursor(); // カーソル表示
  } else if(screenState === "instructions"){
    drawInstructionsScreen();
    cursor(); // カーソル表示
  } else if(screenState === "game"){
    noCursor(); // ゲーム中だけ非表示
    drawGame();
  }
}

// ==================== スタート画面 ====================
function drawStartScreen(){
  push();
  fill(255);
  textAlign(CENTER, CENTER);
  textSize(48);
  text("DOROゲーム", width/2, height/2 - 80);

  rectMode(CENTER);
  // スタートボタン
  fill(50,150,255);
  rect(width/2, height/2, 180, 50, 10);
  fill(255);
  textSize(24);
  text("スタート", width/2, height/2);

  // プレイ方法ボタン
  fill(50,200,100);
  rect(width/2, height/2 + 80, 180, 50, 10);
  fill(255);
  text("プレイ方法", width/2, height/2 + 80);
  pop();
}

// ==================== プレイ方法画面 ====================
function drawInstructionsScreen(){
  push();
  fill(255);
  textAlign(CENTER, CENTER);
  textSize(36);
  text("プレイ方法", width/2, height/2 - 60);
  textSize(24);
  text("DOROを素早く倒したら勝ち！", width/2, height/2 + 20);
  textSize(18);
  text("クリックで戻る", width/2, height/2 + 80);
  pop();
}

// ==================== ゲーム画面 ====================
function drawGame(){
  drawTable();
  updateTargets();
  drawTargets();
  updateBullets();
  drawBullets();
  drawCrosshair();
  handleShooting();
  drawUI();

  if(!gameCleared && doroRemaining <= 0){
    clearTime = (millis() - startTime)/1000;
    gameCleared = true;
  }
}

// ==================== Scene initialization ====================
function initScene(){
  lanes = [];
  targets = [];
  bullets = [];
  ammo = maxAmmo;
  isReloading = false;
  lastFireTime = 0;
  gameCleared = false;

  const minGap = 20;
  const maxGap = 95;
  let y = tableTopY + 12;

  for(let i=0;i<laneCount;i++){
    const t = i / (laneCount - 1);
    const gap = lerp(minGap, maxGap, t);
    const size = lerp(34, 78, t);
    const speed = lerp(1.4, 3.6, t);

    const leftX = map(y, tableTopY, tableBottomY, tableTopLeftX, tableBottomLeftX);
    const rightX = map(y, tableTopY, tableBottomY, tableTopRightX, tableBottomRightX);

    lanes.push({ y, leftX, rightX, size, speed });

    const amp = lerp(22, 30, t);
    const phase = random(TWO_PI);

    for(let j=0;j<Math.ceil(doroRemaining/laneCount); j++){
      const xPos = random(leftX + 20, rightX - 20);
      targets.push({
        lane: i,
        baseX: xPos,
        x: xPos,
        currentY: y,
        baseY: y,
        size,
        dir: random([-1,1]),
        speed,
        alive: true,
        bounceAmp: amp,
        bouncePhase: phase,
        bounceFreq: lerp(0.06, 0.12, random()),
        vx: 0,
        vy: 0
      });
    }

    y += gap;
  }

  startTime = millis();
}

// ==================== Targets ====================
function updateTargets(){
  for(let t of targets){
    if(!t.alive) continue;

    const L = lanes[t.lane];
    const distToMouse = dist(mouseX, mouseY, t.x, t.baseY);
    if(distToMouse < 200){
      const angle = atan2(t.baseY - mouseY, t.x - mouseX);
      t.vx += cos(angle) * 0.35;
      t.vy += sin(angle) * 0.12;
    } else {
      t.vx += t.speed * t.dir * 0.06;
    }

    t.vx += random(-0.04,0.04);
    t.vx = constrain(t.vx,-4.5,4.5);
    t.vy = constrain(t.vy,-1.2,1.2);

    t.x += t.vx;
    t.baseY += t.vy;
    t.baseY = lerp(t.baseY,L.y,0.04);

    const leftBound = L.leftX + 12;
    const rightBound = L.rightX - 12;
    if(t.x < leftBound) t.x = rightBound - 2;
    if(t.x > rightBound) t.x = leftBound + 2;

    const time = frameCount;
    const bounce = sin(time * t.bounceFreq + t.bouncePhase) * t.bounceAmp;
    t.currentY = t.baseY - abs(bounce);
  }
}

function drawTargets(){
  imageMode(CENTER);
  for(let t of targets){
    if(!t.alive) continue;

    push();
    translate(t.x, t.currentY);
    if(t.vx > 0) scale(-1,1); // 右方向なら反転
    image(targetImg, 0, 0, t.size, t.size);
    pop();
  }
}

// ==================== Shooting ====================
function handleShooting(){
  if(!mouseIsPressed || ammo <= 0){
    if(!isReloading && ammo < maxAmmo){
      isReloading = true;
      setTimeout(()=>{
        ammo = maxAmmo;
        isReloading = false;
      }, reloadTime);
    }
    return;
  }

  const now = millis();
  if(now - lastFireTime > fireInterval && !isReloading){
    fireBullet();
    lastFireTime = now;
    ammo--;
  }
}

function fireBullet(){
  const originX = width / 2;
  const originY = height - 6;
  const dx = mouseX - originX;
  const dy = mouseY - originY;
  const d = sqrt(dx*dx + dy*dy) || 1;
  bullets.push({x: originX, y: originY, vx: (dx/d)*20, vy: (dy/d)*20});
}

function updateBullets(){
  for(let i = bullets.length - 1; i >= 0; i--){
    const b = bullets[i];
    b.x += b.vx;
    b.y += b.vy;

    if(b.x < -50 || b.x > width+50 || b.y < -50 || b.y > height+50){
      bullets.splice(i,1);
      continue;
    }

    let hit = false;
    for(let ti = 0; ti < targets.length; ti++){
      const t = targets[ti];
      if(!t.alive) continue;

      const d = dist(b.x, b.y, t.x, t.currentY);
      if(d <= t.size * 0.5){
        t.alive = false;
        bullets.splice(i,1);
        if(doroRemaining > 0) doroRemaining--;
        hit = true;
        break;
      }
    }
    if(hit) continue;
  }
}

function drawBullets(){
  noStroke();
  fill(255,230,130);
  for(let b of bullets){
    ellipse(b.x, b.y, 12);
    push();
    stroke(255,220,130,180);
    strokeWeight(2);
    line(b.x, b.y, b.x - b.vx*0.04, b.y - b.vy*0.04);
    pop();
  }
}

// ==================== Crosshair & UI ====================
function drawCrosshair(){
  push();
  stroke(255,220);
  strokeWeight(2);
  line(mouseX - 10, mouseY, mouseX + 10, mouseY);
  line(mouseX, mouseY - 10, mouseX, mouseY + 10);
  noFill();
  circle(mouseX, mouseY, 18);
  pop();
}

function drawUI(){
  push();
  fill(255);
  textSize(13);
  text("Hold mouse: shoot. Bullets hit targets or leave screen.", 12, 20);
  textSize(16);
  text(`DORO残り ${doroRemaining}匹`, 12, 50);

  textAlign(RIGHT);
  if(isReloading){
    text("Reloading...", width-12, height-20);
  } else {
    text(`${ammo}/${maxAmmo}`, width-12, height-20);
  }

  if(gameCleared){
    textSize(20);
    textAlign(CENTER);
    text(`クリアタイム: ${clearTime.toFixed(2)}秒`, width/2, 30);
  }
  textAlign(LEFT);
  pop();
}

// ==================== Table drawing ====================
function drawTable(){
  noStroke();
  fill(145,100,60);
  quad(
    tableTopLeftX, tableTopY,
    tableTopRightX, tableTopY,
    tableBottomRightX, tableBottomY,
    tableBottomLeftX, tableBottomY
  );
}

// ==================== Mouse pressed ====================
function mousePressed(){
  if(screenState === "start"){
    if(mouseX > width/2 - 90 && mouseX < width/2 + 90 &&
       mouseY > height/2 - 25 && mouseY < height/2 + 25){
      screenState = "game";
      gameStarted = true;
      initScene();
      return;
    }
    if(mouseX > width/2 - 90 && mouseX < width/2 + 90 &&
       mouseY > height/2 + 55 && mouseY < height/2 + 105){
      screenState = "instructions";
      return;
    }
  } else if(screenState === "instructions"){
    screenState = "start";
  } else if(screenState === "game"){
    handleShooting();
  }
}
</script>
</body>
</html>
