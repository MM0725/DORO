<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>DORO射撃ゲーム（動画統合版）</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/addons/p5.sound.min.js"></script>

<style>
  body { margin:0; background:#222; color:#fff; font-family:sans-serif; }
  #hint { position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.4); padding: 8px 12px; font-size: 14px; border-radius: 6px; }
</style>
</head>
<body>

<div id="hint">Hold mouse to shoot / Auto reload</div>

<script>
// ====== 変数 ======
const tableTopLeftX  = 230;
const tableTopRightX = 570;
const tableBottomLeftX  = 80;
const tableBottomRightX = 720;
const tableTopY = 140;
const tableBottomY = 440;
const laneCount = 5;

let doroRemaining = 100;
let maxAmmo = 30;
let ammo = maxAmmo;
let fireInterval = 200;
let lastFireTime = 0;
let reloadTime = 500;
let isReloading = false;

let crosshairSpread = 0;
let crosshairTargetSpread = 0;

let longShootSound = null;
let reloadSound = null;
let isLongSoundPlaying = false;

let shootVid, reloadVid; // ★動画
let startTime = 0;
let clearTime = 0;
let gameCleared = false;

let screenState = "start";
let lanes = [];
let targets = [];
let bullets = [];
let targetImg = null;

const BASE_SCORE = 10000;
let missedShots = 0;
let lastScore = 0;
let highScore = 0;
const HIGH_KEY = "doro_highscore";

function preload() {
  longShootSound = loadSound("sound/shot.mp3");
  reloadSound = loadSound("sound/reload.mp3");
  targetImg = loadImage("images/doro-removebg-preview.png");

  // ★ 射撃エフェクト動画
  shootVid = createVideo("images/ScreenRecording_12-07-2025 21-25-12_1.mov");
  shootVid.hide();
  shootVid.elt.muted = false;

  // ★ リロードエフェクト動画
  reloadVid = createVideo("images/ScreenRecording_12-07-2025 20-27-13_1.mov");
  reloadVid.hide();
  reloadVid.elt.muted = false;
}

function setup() {
  createCanvas(900,600);

  longShootSound?.setVolume(1.0);
  reloadSound?.setVolume(1.0);

  const stored = localStorage.getItem(HIGH_KEY);
  highScore = stored ? parseInt(stored,10) || 0 : 0;
}

function draw() {
  background(36,42,64);

  if(screenState==="start"){ drawStartScreen(); cursor(); }
  else if(screenState==="instructions"){ drawInstructionsScreen(); cursor(); }
  else if(screenState==="game"){ noCursor(); drawGame(); }
  else if(screenState==="clear"){ noCursor(); drawClearScreen(); }
}

function drawStartScreen(){
  fill(255);
  textAlign(CENTER);
  textSize(48);
  text("DOROゲーム", width/2, height/2 - 80);

  fill(50,150,255,200);
  rectMode(CENTER);
  rect(width/2, height/2, 200,60,12);
  fill(255);
  textSize(26);
  text("スタート", width/2, height/2);

  fill(50,200,120,200);
  rect(width/2, height/2 + 90, 200,60,12);
  fill(255);
  text("プレイ方法", width/2, height/2 + 90);
}

function drawInstructionsScreen(){
  fill(255);
  textAlign(CENTER);
  textSize(38);
  text("プレイ方法", width/2, height/2 - 60);

  textSize(22);
  text("DOROを素早く倒したら勝ち！", width/2, height/2 + 10);

  textSize(18);
  text("クリックで戻る", width/2, height/2 + 80);
}

// ====== ゲーム描画 ======
function drawGame(){
  drawTable();
  updateTargets();
  drawTargets();
  updateBullets();
  drawBullets();

  drawGunVideos(); // ★ 追加：動画描画

  drawCrosshair();
  handleShooting();
  drawUI();

  if(!gameCleared && doroRemaining <= 0){
    clearTime = (millis() - startTime)/1000;
    gameCleared = true;
    computeScoreAndSave();
    screenState = "clear";
  }
}

function getGunPos(){
  return { x: width/2, y: height - 10 };
}

function drawGunVideos(){
  let pos = getGunPos();

  if(shootVid && !shootVid.elt.paused){
    image(shootVid, pos.x - 80, pos.y - 80, 160,160);
  }
  if(reloadVid && !reloadVid.elt.paused){
    image(reloadVid, pos.x - 80, pos.y - 80, 160,160);
  }
}
// ====== 的の生成 ======
function initScene(){
  lanes=[]; targets=[]; bullets=[];
  ammo = maxAmmo;
  isReloading = false;
  lastFireTime = 0;
  missedShots = 0;
  gameCleared = false;
  isLongSoundPlaying = false;

  let y = tableTopY + 12;
  const minGap=20, maxGap=95;

  for(let i=0;i<laneCount;i++){
    const t=i/(laneCount-1);
    const gap=lerp(minGap,maxGap,t);
    const size=lerp(34,78,t);
    const speed=lerp(1.4,3.6,t);

    const leftX = map(y,tableTopY,tableBottomY,tableTopLeftX,tableBottomLeftX);
    const rightX= map(y,tableTopY,tableBottomY,tableTopRightX,tableBottomRightX);

    lanes.push({y,leftX,rightX,size,speed});

    const amp = lerp(22,30,t);
    const phase = random(TWO_PI);
    const freq = lerp(0.06,0.12,random());

    for(let j=0;j<Math.ceil(doroRemaining/laneCount);j++){
      const px = random(leftX+20,rightX-20);
      targets.push({
        lane:i,
        baseX:px, x:px,
        baseY:y, currentY:y,
        size,
        alive:true,
        vx:0, vy:0,
        dir:random([-1,1]),
        speed,
        bounceAmp:amp,
        bouncePhase:phase,
        bounceFreq:freq
      });
    }

    y += gap;
  }

  startTime = millis();
}

// ====== 的の動作 ======
function updateTargets(){
  for(let t of targets){
    if(!t.alive) continue;

    const L = lanes[t.lane];
    const d = dist(mouseX,mouseY,t.x,t.baseY);

    if(d < 200){
      const ang = atan2(t.baseY - mouseY, t.x - mouseX);
      t.vx += cos(ang)*0.35;
      t.vy += sin(ang)*0.12;
    } else {
      t.vx += t.speed * t.dir * 0.06;
    }

    t.vx += random(-0.04,0.04);
    t.vx = constrain(t.vx,-4.5,4.5);
    t.vy = constrain(t.vy,-1.2,1.2);

    t.x += t.vx;
    t.baseY += t.vy;
    t.baseY = lerp(t.baseY, L.y, 0.04);

    const leftBound = L.leftX + 12;
    const rightBound = L.rightX - 12;

    if(t.x < leftBound) t.x = rightBound - 2;
    if(t.x > rightBound) t.x = leftBound + 2;

    const time = frameCount;
    const bounce = sin(time*t.bounceFreq + t.bouncePhase) * t.bounceAmp;
    t.currentY = t.baseY - abs(bounce);
  }
}

function drawTargets(){
  imageMode(CENTER);
  for(let t of targets){
    if(!t.alive) continue;

    push();
    translate(t.x, t.currentY);
    if(t.vx > 0) scale(-1,1);

    if(targetImg) image(targetImg,0,0,t.size,t.size);
    else { fill(255,100,100); ellipse(0,0,t.size); }

    pop();
  }
}

// ====== 弾 ======
function fireBullet(){
  const gun = getGunPos();
  const dx = mouseX - gun.x;
  const dy = mouseY - gun.y;
  const d = sqrt(dx*dx + dy*dy) || 1;

  bullets.push({
    x:gun.x,
    y:gun.y,
    vx:(dx/d)*20,
    vy:(dy/d)*20
  });
}

function updateBullets(){
  for(let i=bullets.length-1;i>=0;i--){
    let b = bullets[i];
    b.x += b.vx;
    b.y += b.vy;

    if(b.x < -50 || b.x > width+50 ||
       b.y < -50 || b.y > height+50){
      missedShots++;
      bullets.splice(i,1);
      continue;
    }

    for(let t of targets){
      if(!t.alive) continue;

      const d = dist(b.x,b.y,t.x,t.currentY);
      if(d <= t.size*0.5){
        t.alive = false;
        bullets.splice(i,1);
        doroRemaining--;
        break;
      }
    }
  }
}

function drawBullets(){
  fill(255,230,130);
  noStroke();
  for(let b of bullets) ellipse(b.x,b.y,12);
}

// ====== クロスヘア ======
function drawCrosshair(){
  crosshairSpread = lerp(crosshairSpread, crosshairTargetSpread, 0.15);
  crosshairTargetSpread *= 0.85;

  stroke(255);
  strokeWeight(2);
  let cx = mouseX, cy = mouseY;

  line(cx, cy - 20 - crosshairSpread, cx, cy - 5);
  line(cx, cy + 5, cy, cy + 20 + crosshairSpread);

  line(cx - (20 + crosshairSpread), cy, cx - 5, cy);
  line(cx + 5, cy, cx + (20 + crosshairSpread), cy);
}

// ====== UI ======
function drawUI(){
  fill(255);
  textSize(16);
  text(`DORO残り ${doroRemaining}匹`, 10, 50);

  // ★弾数バー（右から減る）
  const barX = mouseX - 70;
  const barY = mouseY - 20;
  const barW = 60;
  const barH = 10;

  let barColor = color(255);
  if(isReloading || ammo <= 0) barColor = color(150);
  else if(ammo <= maxAmmo/2) barColor = color(255,0,0);

  noStroke();
  fill(80);
  rect(barX, barY, barW, barH, 4);

  let filled = (ammo/maxAmmo) * barW;
  fill(barColor);
  rect(barX + (barW - filled), barY, filled, barH, 4);

  fill(barColor);
  textSize(14);
  text(String(ammo).padStart(3,"0"), barX, barY + barH + 14);

  fill(255);
  textSize(14);
  text(`外した弾: ${missedShots}`, 10, 70);
}

// ====== 射撃・リロード ======
function handleShooting(){
  // 離した時・弾切れ → 射撃音停止 & リロード
  if(!mouseIsPressed || ammo <= 0){
    if(isLongSoundPlaying){
      longShootSound.stop();
      isLongSoundPlaying = false;
    }

    // ★ リロード開始
    if(!isReloading && ammo < maxAmmo){
      isReloading = true;
      reloadSound.play();

      reloadVid.stop();
      reloadVid.play();
      setTimeout(()=> reloadVid.stop(), 300);

      setTimeout(()=>{
        ammo = maxAmmo;
        isReloading = false;
      }, reloadTime);
    }
    return;
  }

  // ★射撃開始時動画
  if(!isLongSoundPlaying){
    longShootSound.play();
    isLongSoundPlaying = true;

    shootVid.stop();
    shootVid.play();
    setTimeout(()=> shootVid.stop(), 150);
  }

  const now = millis();
  if(now - lastFireTime > fireInterval && !isReloading){
    fireBullet();
    lastFireTime = now;
    ammo--;
    crosshairTargetSpread = 12;
  }
}

// ====== スコア ======
function computeScoreAndSave(){
  const timePenaltyPerSec = 50;
  const missPenalty = 20;

  let score = BASE_SCORE
            - Math.floor(clearTime * timePenaltyPerSec)
            - (missedShots * missPenalty);

  if(score < 0) score = 0;
  lastScore = score;

  if(score > highScore){
    highScore = score;
    localStorage.setItem(HIGH_KEY, String(highScore));
  }
}

// ====== クリア画面 ======
function drawClearScreen(){
  textAlign(CENTER);
  fill(255);
  textSize(56);
  text("CLEAR!", width/2, height/2 - 120);

  textSize(20);
  text(`クリア時間: ${clearTime.toFixed(2)} 秒`, width/2, height/2 - 60);
  text(`外した弾: ${missedShots} 発`, width/2, height/2 - 30);

  textSize(18);
  text(`スコア: ${lastScore}`, width/2, height/2 + 40);
  text(`ハイスコア: ${highScore}`, width/2, height/2 + 80);

  rectMode(CENTER);
  fill(200,230,255);
  rect(width/2 - 120, height/2 + 150, 160,44,8);
  fill(20);
  text("リトライ", width/2 - 120, height/2 + 150);

  fill(200,230,255);
  rect(width/2 + 120, height/2 + 150, 160,44,8);
  fill(20);
  text("タイトルへ", width/2 + 120, height/2 + 150);
}

// ====== マウス操作 ======
function mousePressed(){
  if(getAudioContext().state !== "running") getAudioContext().resume();

  if(screenState==="start"){
    if(mouseX>width/2-100 && mouseX<width/2+100 &&
       mouseY>height/2-30 && mouseY<height/2+30){
      screenState="game";
      initScene();
      return;
    }
    if(mouseX>width/2-100 && mouseX<width/2+100 &&
       mouseY>height/2+60 && mouseY<height/2+120){
      screenState="instructions";
      return;
    }
  }

  if(screenState==="instructions"){
    screenState="start";
    return;
  }

  if(screenState==="clear"){
    const rx = width/2 - 120, ry = height/2 + 150, w=160,h=44;
    if(mouseX>rx-w/2 && mouseX<rx+w/2 &&
       mouseY>ry-h/2 && mouseY<ry+h/2){
      doroRemaining = 100;
      screenState="game";
      initScene();
      return;
    }

    const tx = width/2 + 120, ty = height/2 + 150;
    if(mouseX>tx-w/2 && mouseX<tx+w/2 &&
       mouseY>ty-h/2 && mouseY<ty+h/2){
      screenState="start";
      return;
    }
  }
}

// ====== テーブル描画 ======
function drawTable(){
  noStroke();
  fill(145,100,60);
  quad(
    tableTopLeftX, tableTopY,
    tableTopRightX, tableTopY,
    tableBottomRightX, tableBottomY,
    tableBottomLeftX, tableBottomY
  );
}
</script>
</body>
</html>
