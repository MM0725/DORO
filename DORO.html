<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>DORO射的ゲーム（クロスヘア拡張版 + 射撃音）</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/addons/p5.sound.min.js"></script>
<style>
  html,body{height:100%;margin:0;background:#222;color:#fff;font-family:system-ui}
  #hint{position:fixed;left:12px;top:12px;background:rgba(0,0,0,0.36);
        padding:8px 10px;border-radius:8px;font-size:13px;z-index:10}
</style>
</head>
<body>
<div id="hint">Hold mouse: shoot. Auto reload when released or empty.</div>

<script>
// ======================================================
// 基本設定
// ======================================================
const tableTopLeftX  = 230;
const tableTopRightX = 570;
const tableBottomLeftX  = 80;
const tableBottomRightX = 720;
const tableTopY = 140;
const tableBottomY = 440;
const laneCount = 5;

let doroRemaining = 100;

// 弾
let maxAmmo = 30;
let ammo = maxAmmo;
let fireInterval = 200;
let lastFireTime = 0;
let reloadTime = 500;
let isReloading = false;

// クロスヘア広がりアニメ
let crosshairSpread = 0;
let crosshairTargetSpread = 0;

// 射撃音
let shootSound = null;

// クリアタイム
let startTime;
let clearTime = null;
let gameCleared = false;

// 画面
let screenState = "start";

let lanes = [];
let targets = [];
let bullets = [];
let targetImg;

// ======================================================
// p5.js setup
// ======================================================
function setup(){
  createCanvas(900, 600);
  // 画像はあれば表示されます（なくても動作）
  targetImg = loadImage("images/doro-removebg-preview.png", ()=>{}, ()=>{ /* ignore load error */ });

  // 射撃音をロード（ファイルパス：sound/射撃音.MP3）
  // ブラウザによってはユーザー操作があるまで再生制限があるため、
  // loadSound はここで呼んでおき、再生自体はユーザー操作時に行います。
  try{
    shootSound = loadSound("sound/射撃音.MP3", 
      ()=>{ /* loaded */ }, 
      ()=>{ /* failed to load - ignore */ }
    );
  } catch(e){
    // 安全のため何もしない
    shootSound = null;
  }
}

// ======================================================
// draw
// ======================================================
function draw(){
  background(36,42,64);

  if(screenState === "start"){
    drawStartScreen();
    cursor();
  } else if(screenState === "instructions"){
    drawInstructionsScreen();
    cursor();
  } else if(screenState === "game"){
    noCursor();
    drawGame();
  }
}

// ======================================================
// Start Screen
// ======================================================
function drawStartScreen(){
  push();
  fill(255);
  textAlign(CENTER, CENTER);
  textSize(48);
  text("DOROゲーム", width/2, height/2 - 80);

  rectMode(CENTER);

  fill(50,150,255);
  rect(width/2, height/2, 180, 50, 10);
  fill(255);
  textSize(24);
  text("スタート", width/2, height/2);

  fill(50,200,100);
  rect(width/2, height/2 + 80, 180, 50, 10);
  fill(255);
  text("プレイ方法", width/2, height/2 + 80);

  pop();
}

function drawInstructionsScreen(){
  push();
  fill(255);
  textAlign(CENTER, CENTER);
  textSize(36);
  text("プレイ方法", width/2, height/2 - 60);
  textSize(24);
  text("DOROを素早く倒したら勝ち！", width/2, height/2 + 20);
  textSize(18);
  text("クリックで戻る", width/2, height/2 + 80);
  pop();
}

// ======================================================
// Game Screen
// ======================================================
function drawGame(){
  drawTable();
  updateTargets();
  drawTargets();
  updateBullets();
  drawBullets();
  drawCrosshair();
  handleShooting();
  drawUI();

  if(!gameCleared && doroRemaining <= 0){
    clearTime = (millis() - startTime)/1000;
    gameCleared = true;
  }
}

// ======================================================
// Scene Init
// ======================================================
function initScene(){
  lanes = [];
  targets = [];
  bullets = [];

  ammo = maxAmmo;
  isReloading = false;
  lastFireTime = 0;
  gameCleared = false;

  const minGap = 20;
  const maxGap = 95;
  let y = tableTopY + 12;

  for(let i=0;i<laneCount;i++){
    const t = i/(laneCount-1);
    const gap = lerp(minGap, maxGap, t);
    const size = lerp(34,78,t);
    const speed= lerp(1.4,3.6,t);

    const leftX = map(y, tableTopY, tableBottomY, tableTopLeftX, tableBottomLeftX);
    const rightX= map(y, tableTopY, tableBottomY, tableTopRightX, tableBottomRightX);

    lanes.push({y,leftX,rightX,size,speed});

    const amp = lerp(22,30,t);
    const phase = random(TWO_PI);

    for(let j=0;j<Math.ceil(doroRemaining/laneCount); j++){
      const xPos = random(leftX+20, rightX-20);
      targets.push({
        lane:i,
        baseX:xPos,
        x:xPos,
        currentY:y,
        baseY:y,
        size,
        dir:random([-1,1]),
        speed,
        alive:true,
        bounceAmp:amp,
        bouncePhase:phase,
        bounceFreq:lerp(0.06,0.12,random()),
        vx:0,
        vy:0
      });
    }
    y += gap;
  }

  startTime = millis();
}

// ======================================================
// Target Update
// ======================================================
function updateTargets(){
  for(let t of targets){
    if(!t.alive) continue;

    const L = lanes[t.lane];
    const d = dist(mouseX,mouseY,t.x,t.baseY);

    if(d < 200){
      const ang = atan2(t.baseY - mouseY, t.x - mouseX);
      t.vx += cos(ang)*0.35;
      t.vy += sin(ang)*0.12;
    } else {
      t.vx += t.speed * t.dir * 0.06;
    }

    t.vx += random(-0.04,0.04);
    t.vx = constrain(t.vx,-4.5,4.5);
    t.vy = constrain(t.vy,-1.2,1.2);

    t.x += t.vx;
    t.baseY += t.vy;
    t.baseY = lerp(t.baseY, L.y, 0.04);

    const leftBound = L.leftX + 12;
    const rightBound= L.rightX - 12;
    if(t.x < leftBound) t.x = rightBound - 2;
    if(t.x > rightBound) t.x = leftBound + 2;

    const time = frameCount;
    const bounce = sin(time*t.bounceFreq + t.bouncePhase) * t.bounceAmp;
    t.currentY = t.baseY - abs(bounce);
  }
}

function drawTargets(){
  imageMode(CENTER);
  for(let t of targets){
    if(!t.alive) continue;
    push();
    translate(t.x, t.currentY);
    if(t.vx > 0) scale(-1,1);
    // 画像が無くても ellipse による代替表示を残す
    if(targetImg && targetImg.width > 0){
      image(targetImg,0,0,t.size,t.size);
    } else {
      noStroke();
      fill(250,120,120);
      ellipse(0,0,t.size);
      fill(255);
      ellipse(0,0,t.size*0.58);
      fill(220,20,20);
      ellipse(0,0,t.size*0.28);
    }
    pop();
  }
}

// ======================================================
// Shooting
// ======================================================
function handleShooting(){
  if(!mouseIsPressed || ammo <= 0){
    if(!isReloading && ammo < maxAmmo){
      isReloading = true;
      setTimeout(()=>{
        ammo = maxAmmo;
        isReloading = false;
      }, reloadTime);
    }
    return;
  }

  const now = millis();
  if(now - lastFireTime > fireInterval && !isReloading){
    fireBullet();
    lastFireTime = now;
    ammo--;

    // ★撃った瞬間にクロスヘア拡大
    crosshairTargetSpread = 12;
  }
}

function fireBullet(){
  // ★ 撃つ音を鳴らす（ロードされていれば）
  try {
    if (shootSound && shootSound.isLoaded && shootSound.isLoaded()) {
      // 音が重なりやすい連射時は短めに再生（必要なら音量や playbackRate を調整）
      shootSound.play();
    } else if (shootSound && typeof shootSound.play === 'function') {
      // isLoaded が無くても play を試す（フォールバック）
      shootSound.play();
    }
  } catch(e){
    // 音再生失敗は無視
  }

  const ox = width/2;
  const oy = height - 6;
  const dx = mouseX - ox;
  const dy = mouseY - oy;
  const d = sqrt(dx*dx+dy*dy)||1;

  bullets.push({
    x:ox, y:oy,
    vx:(dx/d)*20,
    vy:(dy/d)*20
  });
}

// ======================================================
// Bullets
// ======================================================
function updateBullets(){
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    b.x += b.vx;
    b.y += b.vy;

    if(b.x<-50 || b.x>width+50 || b.y<-50 || b.y>height+50){
      bullets.splice(i,1);
      continue;
    }

    let hit = false;
    for(let ti=0;ti<targets.length;ti++){
      const t = targets[ti];
      if(!t.alive) continue;
      const d = dist(b.x,b.y,t.x,t.currentY);
      if(d <= t.size*0.5){
        t.alive=false;
        bullets.splice(i,1);
        if(doroRemaining>0) doroRemaining--;
        hit=true;
        break;
      }
    }
    if(hit) continue;
  }
}

function drawBullets(){
  noStroke();
  fill(255,230,130);
  for(let b of bullets){
    ellipse(b.x,b.y,12);
    push();
    stroke(255,220,130,180);
    strokeWeight(2);
    line(b.x,b.y,b.x-b.vx*0.04,b.y-b.vy*0.04);
    pop();
  }
}

// ======================================================
// ★ 新クロスヘア（撃つと広がる）
// ======================================================
function drawCrosshair(){
  // スプレッドが自然に戻る
  crosshairSpread = lerp(crosshairSpread, crosshairTargetSpread, 0.15);
  crosshairTargetSpread *= 0.85;

  const cx = mouseX;
  const cy = mouseY;

  push();
  stroke(255);
  strokeWeight(2);

  // 縦線（上下に開く）
  line(cx, cy - 15 - crosshairSpread, cx, cy - 5);
  line(cx, cy + 5, cx, cy + 15 + crosshairSpread);

  // 横線（左右に開く）
  line(cx - (15 + crosshairSpread), cy, cx - 5, cy);
  line(cx + 5, cy, cx + (15 + crosshairSpread), cy);

  pop();
}

// ======================================================
// UI（残弾バー & カウンター）
// ======================================================
function drawUI(){
  push();
  fill(255);
  textSize(13);
  text("Hold mouse: shoot / Auto reload", 12, 20);
  textSize(16);
  text(`DORO残り ${doroRemaining}匹`, 12, 50);
  pop();

  // ----- 残弾バー -----
  const barWidth = 50;
  const barHeight = 12;

  const barX = mouseX - 70;
  const barY = mouseY - barHeight/2;

  let barColor;
  if(isReloading || ammo <= 0) barColor = color(150);
  else if(ammo <= maxAmmo/2)  barColor = color(255,0,0);
  else barColor = color(255);

  // 背景
  push();
  noStroke();
  fill(80);
  rect(barX, barY, barWidth, barHeight, 4);

  // 残量バー
  fill(barColor);
  rect(barX, barY, (ammo/maxAmmo)*barWidth, barHeight, 4);
  pop();

  // 三桁カウンター
  push();
  textSize(16);
  textAlign(LEFT, TOP);
  fill(barColor);
  text(String(ammo).padStart(3,'0'), barX, barY + barHeight + 4);
  pop();

  // クリアタイム
  if(gameCleared){
    push();
    textSize(20);
    textAlign(CENTER);
    fill(255);
    text(`クリアタイム: ${clearTime.toFixed(2)}秒`, width/2, 30);
    pop();
  }
}

// ======================================================
// Table
// ======================================================
function drawTable(){
  noStroke();
  fill(145,100,60);
  quad(
    tableTopLeftX, tableTopY,
    tableTopRightX, tableTopY,
    tableBottomRightX, tableBottomY,
    tableBottomLeftX, tableBottomLeftY ? tableBottomY : tableBottomY
  );
}

// ======================================================
// Mouse
// ======================================================
function mousePressed(){
  if(screenState==="start"){
    if(mouseX>width/2-90 && mouseX<width/2+90 &&
       mouseY>height/2-25 && mouseY<height/2+25){
      screenState="game";
      initScene();
      return;
    }
    if(mouseX>width/2-90 && mouseX<width/2+90 &&
       mouseY>height/2+55 && mouseY<height/2+105){
      screenState="instructions";
      return;
    }
  } else if(screenState==="instructions"){
    screenState="start";
  } else if(screenState==="game"){
    handleShooting();
  }
}
</script>
</body>
</html>
