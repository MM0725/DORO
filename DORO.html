<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>DORO射撃ゲーム（完全統合版 — スコア実装）</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/addons/p5.sound.min.js"></script>

<style>
  body { margin:0; background:#222; color:#fff; font-family:sans-serif; }
  #hint { position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.4); padding: 8px 12px; font-size: 14px; border-radius: 6px; }
</style>
</head>
<body>

<div id="hint">Hold mouse to shoot / Auto reload</div>

<script>
// =========================
// 基本変数
// =========================
const tableTopLeftX  = 230;
const tableTopRightX = 570;
const tableBottomLeftX  = 80;
const tableBottomRightX = 720;
const tableTopY = 140;
const tableBottomY = 440;
const laneCount = 5;

let doroRemaining = 100;

let maxAmmo = 30;
let ammo = maxAmmo;
let fireInterval = 200;
let lastFireTime = 0;
let reloadTime = 500;
let isReloading = false;

let crosshairSpread = 0;
let crosshairTargetSpread = 0;

let longShootSound = null;   
let reloadSound = null;      
let isLongSoundPlaying = false;

let startTime = 0;
let clearTime = 0;
let gameCleared = false;

let screenState = "start";

let lanes = [];
let targets = [];
let bullets = [];
let targetImg = null;

// --- スコア用
const BASE_SCORE = 10000;
let missedShots = 0;
let lastScore = 0;
let highScore = 0;
const HIGH_KEY = "doro_highscore";

// =========================
// preload 読み込み
// =========================
function preload() {
  longShootSound = loadSound("sound/shot.mp3");
  reloadSound    = loadSound("sound/reload.mp3");
  targetImg      = loadImage("images/doro-removebg-preview.png");
}

function setup() {
  createCanvas(900, 600);

  try { if(longShootSound) longShootSound.setVolume(1.0); } catch(e){}
  try { if(reloadSound) reloadSound.setVolume(1.0); } catch(e){}

  const stored = localStorage.getItem(HIGH_KEY);
  highScore = stored ? parseInt(stored,10)||0 : 0;
}

// =========================
function draw() {
  background(36,42,64);

  if(screenState === "start")       { drawStartScreen(); cursor(); }
  else if(screenState === "instructions"){ drawInstructionsScreen(); cursor(); }
  else if(screenState === "game")   { noCursor(); drawGame(); }
  else if(screenState === "clear")  { noCursor(); drawClearScreen(); }
}

// =========================
// スタート画面
// =========================
function drawStartScreen(){
  push();
  fill(255);
  textAlign(CENTER);
  textSize(48);
  text("DOROゲーム", width/2, height/2 - 80);

  rectMode(CENTER);

  fill(50,150,255);
  rect(width/2, height/2, 200, 60, 12);
  fill(255);
  textSize(26);
  text("スタート", width/2, height/2);

  fill(50,200,120);
  rect(width/2, height/2 + 90, 200, 60, 12);
  fill(255);
  text("プレイ方法", width/2, height/2 + 90);
  pop();
}

function drawInstructionsScreen(){
  push();
  fill(255);
  textAlign(CENTER);
  textSize(38);
  text("プレイ方法", width/2, height/2 - 60);
  textSize(22);
  text("DOROを素早く倒したら勝ち！", width/2, height/2 + 10);
  textSize(18);
  text("クリックで戻る", width/2, height/2 + 80);
  pop();
}

// =========================
// メインゲーム
// =========================
function drawGame(){
  drawTable();
  updateTargets();
  drawTargets();
  updateBullets();
  drawBullets();
  drawCrosshair();
  handleShooting();
  drawUI();

  if(!gameCleared && doroRemaining <= 0){
    clearTime = (millis() - startTime)/1000;
    gameCleared = true;

    // ★ クリア時に射撃音を必ず停止
    try { 
      if(longShootSound && isLongSoundPlaying) longShootSound.stop();
    } catch(e){}
    isLongSoundPlaying = false;

    computeScoreAndSave();
    screenState = "clear";
  }
}

// =========================
function initScene(){
  lanes=[]; targets=[]; bullets=[];
  ammo = maxAmmo;
  isReloading = false;
  lastFireTime = 0;
  gameCleared = false;
  isLongSoundPlaying = false;
  missedShots = 0;
  lastScore = 0;

  const minGap = 20; const maxGap = 95;
  let y = tableTopY + 12;

  for(let i=0;i<laneCount;i++){
    const t = i/(laneCount-1);
    const gap = lerp(minGap,maxGap,t);
    const size = lerp(34,78,t);
    const speed = lerp(1.4,3.6,t);

    const leftX = map(y,tableTopY,tableBottomY,tableTopLeftX,tableBottomLeftX);
    const rightX= map(y,tableTopY,tableBottomY,tableTopRightX,tableBottomRightX);

    lanes.push({y,leftX,rightX,size,speed});

    const amp = lerp(22,30,t);
    const phase = random(TWO_PI);

    for(let j=0;j<Math.ceil(doroRemaining/laneCount); j++){
      const xPos = random(leftX+20,rightX-20);
      targets.push({
        lane:i, baseX:xPos, x:xPos, currentY:y, baseY:y,
        size, dir:random([-1,1]), speed,
        alive:true,
        bounceAmp:amp, bouncePhase:phase, bounceFreq:lerp(0.06,0.12,random()),
        vx:0, vy:0
      });
    }
    y += gap;
  }

  startTime = millis();
}

// =========================
// ターゲット挙動
// =========================
function updateTargets(){
  for(let t of targets){
    if(!t.alive) continue;

    const L = lanes[t.lane];
    const d = dist(mouseX,mouseY,t.x,t.baseY);

    if(d < 200){
      const ang = atan2(t.baseY - mouseY, t.x - mouseX);
      t.vx += cos(ang)*0.35; t.vy += sin(ang)*0.12;
    } else {
      t.vx += t.speed * t.dir * 0.06;
    }

    t.vx += random(-0.04,0.04);
    t.vx = constrain(t.vx,-4.5,4.5);
    t.vy = constrain(t.vy,-1.2,1.2);

    t.x += t.vx;
    t.baseY += t.vy;
    t.baseY = lerp(t.baseY, L.y, 0.04);

    const leftBound = L.leftX + 12;
    const rightBound = L.rightX - 12;

    if(t.x < leftBound) t.x = rightBound - 2;
    if(t.x > rightBound) t.x = leftBound + 2;

    const time = frameCount;
    const bounce = sin(time*t.bounceFreq + t.bouncePhase) * t.bounceAmp;
    t.currentY = t.baseY - abs(bounce);
  }
}

// =========================
// ターゲット描画
// =========================
function drawTargets(){
  imageMode(CENTER);
  for(let t of targets){
    if(!t.alive) continue;
    push();
    translate(t.x,t.currentY);
    if(t.vx>0) scale(-1,1);
    if(targetImg) image(targetImg,0,0,t.size,t.size);
    else { fill(255,100,100); ellipse(0,0,t.size); }
    pop();
  }
}

// =========================
// 弾
// =========================
function fireBullet(){
  const ox = width/2;
  const oy = height - 10;
  const dx = mouseX - ox;
  const dy = mouseY - oy;
  const d = sqrt(dx*dx + dy*dy)||1;

  bullets.push({
    x:ox, y:oy,
    vx:(dx/d)*20, vy:(dy/d)*20
  });
}

function updateBullets(){
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];

    b.x += b.vx;
    b.y += b.vy;

    if(b.x < -50 || b.x > width+50 || b.y < -50 || b.y > height+50){
      missedShots++;
      bullets.splice(i,1);
      continue;
    }

    for(let t of targets){
      if(!t.alive) continue;

      const d = dist(b.x,b.y,t.x,t.currentY);
      if(d <= t.size*0.5){
        t.alive = false;
        bullets.splice(i,1);
        if(doroRemaining>0) doroRemaining--;
        break;
      }
    }
  }
}

function drawBullets(){
  noStroke();
  fill(255,230,130);
  for(let b of bullets) ellipse(b.x,b.y,12);
}

// =========================
// クロスヘア
// =========================
function drawCrosshair(){
  crosshairSpread = lerp(crosshairSpread, crosshairTargetSpread, 0.15);
  crosshairTargetSpread *= 0.85;

  const cx = mouseX;
  const cy = mouseY;

  push();
  stroke(255); strokeWeight(2);

  line(cx, cy - 20 - crosshairSpread, cx, cy - 5);
  line(cx, cy + 5, cx, cy + 20 + crosshairSpread);

  line(cx - (20 + crosshairSpread), cy, cx - 5, cy);
  line(cx + 5, cy, cx + (20 + crosshairSpread), cy);

  pop();
}

// =========================
// UI
// =========================
function drawUI(){
  push();
  fill(255); textSize(16);
  text(`DORO残り ${doroRemaining}匹`, 10, 50);
  pop();

  const barX = mouseX - 70;
  const barY = mouseY - 20;
  const barW = 60;
  const barH = 10;

  let barColor = color(255);
  if(isReloading || ammo <= 0) barColor = color(150);
  else if(ammo <= maxAmmo/2) barColor = color(255,0,0);

  push();
  noStroke();
  fill(80);
  rect(barX, barY, barW, barH, 4);
  fill(barColor);
  rect(barX, barY, (ammo/maxAmmo)*barW, barH, 4);
  pop();

  push();
  textSize(14);
  fill(barColor);
  text(String(ammo).padStart(3,"0"), barX, barY + barH + 14);
  pop();

  push();
  fill(255);
  text(`外した弾: ${missedShots}`, 10, 70);
  pop();
}

// =========================
// 射撃・リロード（音）
// =========================
function handleShooting(){
  if(!mouseIsPressed || ammo <= 0){
    if(isLongSoundPlaying){
      longShootSound.stop();
      isLongSoundPlaying = false;
    }

    if(!isReloading && ammo < maxAmmo){
      isReloading = true;

      try { reloadSound.play(); } catch(e){}

      setTimeout(()=>{
        ammo = maxAmmo;
        isReloading = false;
      }, reloadTime);
    }

    return;
  }

  if(!isLongSoundPlaying){
    try{ if(getAudioContext().state !== "running") getAudioContext().resume(); }catch(e){}
    try{
      longShootSound.play();
      isLongSoundPlaying = true;
    }catch(e){}
  }

  const now = millis();
  if(now - lastFireTime > fireInterval && !isReloading){
    fireBullet();
    lastFireTime = now;
    ammo--;
    crosshairTargetSpread = 12;
  }
}

// =========================
// スコア計算（あなた指定）
// =========================
function computeScoreAndSave(){
  const timePenaltyPerSec = 50;  // ← あなたの指定
  const missPenalty       = 20;  // ← あなたの指定

  const timePenalty = clearTime * timePenaltyPerSec;
  const missPenaltyTotal = missedShots * missPenalty;

  let score = BASE_SCORE - timePenalty - missPenaltyTotal;

  score = Math.max(0, Math.floor(score));
  lastScore = score;

  if(score > highScore){
    highScore = score;
    localStorage.setItem(HIGH_KEY,String(highScore));
  }
}

// =========================
// CLEAR画面
// =========================
function drawClearScreen(){
  push();
  fill(255);
  textAlign(CENTER);
  textSize(56);
  text("CLEAR!", width/2, height/2 - 120);

  textSize(20);
  text(`クリア時間: ${clearTime.toFixed(2)} 秒`, width/2, height/2 - 60);
  text(`外した弾: ${missedShots} 発`, width/2, height/2 - 30);

  // 内訳
  const timePenaltyPerSec = 50;
  const missPenalty = 20;

  textSize(18);
  text(`計算: ${BASE_SCORE} - (時間 ${clearTime.toFixed(2)}s × ${timePenaltyPerSec}) - (外し ${missedShots} × ${missPenalty})`,
       width/2, height/2 + 0);

  textSize(36);
  text(`スコア: ${lastScore}`, width/2, height/2 + 60);

  textSize(20);
  text(`ハイスコア: ${highScore}`, width/2, height/2 + 110);

  textSize(26);
  fill(200,230,255);
  text("クリックでタイトルへ", width/2, height/2 + 170);

  pop();
}

function mousePressed(){
  try{ if(getAudioContext().state !== "running") getAudioContext().resume(); }catch(e){}

  if(screenState === "start"){
    if(mouseX>width/2-100 && mouseX<width/2+100 &&
       mouseY>height/2-30 && mouseY<height/2+30){
      screenState = "game"; doroRemaining=100; initScene(); return;
    }

    if(mouseX>width/2-100 && mouseX<width/2+100 &&
       mouseY>height/2+60 && mouseY<height/2+120){
      screenState = "instructions"; return;
    }
  }

  if(screenState === "instructions"){
    screenState = "start";
  }

  if(screenState === "clear"){
    screenState = "start";
  }
}

// =========================
// テーブル描画
// =========================
function drawTable(){
  noStroke();
  fill(145,100,60);
  quad(
    tableTopLeftX, tableTopY,
    tableTopRightX, tableTopY,
    tableBottomRightX, tableBottomY,
    tableBottomLeftX, tableBottomY
  );
}
</script>
</body>
</html>
